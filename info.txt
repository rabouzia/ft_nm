1. ELF File Format (Executable and Linkable Format)

    What is ELF?: The ELF format is used for executables, object files, shared libraries, and core dumps on Unix-like systems. It's a binary format that describes how an executable is structured.
        ELF Header: The first part of the ELF file that tells us about the file structure and where to find sections and program headers.
        Sections: ELF files are divided into sections, each with a specific purpose (e.g., code, data, symbol table, etc.).
        Program Header: Describes how the program should be loaded into memory.
        Section Header: Contains metadata about each section in the file.

What you need to learn:

    Structure of the ELF file (mainly ELF header, Section headers, and Symbol table).
    Key terms: e_ident, e_shoff, e_shnum, e_shstrndx, SHT_SYMTAB (symbol table section).

Resources:

    Read ELF format.
    Check out the ELF specification.

2. System Calls

Since you're restricted to system calls, it’s important to know how to interact with the operating system at a low level. You’ll be using functions like:

    open(): Opens a file.
    close(): Closes an open file descriptor.
    read() / write(): Reads from or writes to a file descriptor.
    fstat(): Retrieves the size and metadata of a file.
    mmap(): Maps a file into memory for easier access.
    munmap(): Unmaps a file from memory.
    perror(): Prints error messages based on system call failures.

What you need to learn:

    Basics of file I/O in Unix/Linux.
    How to interact with memory and files using system calls.

Resources:

    Learn about system calls.
    Linux system programming

3. Memory Management and Mappings

    mmap() and munmap(): These functions allow you to map files into memory, which is more efficient than reading them byte-by-byte with read().
    Why mmap()?: This allows you to treat a file as a large array of memory, simplifying the parsing of complex file formats like ELF.

What you need to learn:

    Memory mapping and accessing mapped memory.
    How mmap() allows you to read the ELF file in a structured way.

Resources:

    Learn more about memory mapping in Linux.

4. Symbol Tables and Linking

    What are Symbols?: Symbols are names for variables, functions, and other objects in an executable. These symbols are used for linking and debugging.
    Symbol Table: Contains a list of symbols and their associated information like:
        Symbol Name: The actual name of the function/variable.
        Symbol Address: The address in memory where the symbol is located.
        Symbol Type: Function, object, etc.
        Symbol Binding: Whether the symbol is local or global.
    What nm Does: The nm command lists all the symbols in an object file or executable.

What you need to learn:

    Understand the structure of a symbol table in ELF files.
    Different types of symbols (e.g., functions vs. variables).
    Symbol binding (e.g., global, local, undefined).

Resources:

    Understanding symbol tables.
    NM command usage.

5. Hexadecimal and Binary Representation

    Why Hex?: Binary data is often printed in hexadecimal format for readability, as it's more compact and easier to parse.
    Converting to Hex: You’ll need to print addresses, section offsets, and other data in hexadecimal format, which is a common practice for examining low-level data.

What you need to learn:

    How to print data in hexadecimal format.
    Converting between decimal and hexadecimal.

Resources:

    Hexadecimal numbers explained.

6. Linking and Loading

    Linking: When building an executable, multiple object files are linked together. The symbol table helps resolve references between them.
    Dynamic Linking: Many executables depend on shared libraries (e.g., libc.so). These symbols may be undefined in the object file but resolved at runtime.
    Dynamic Symbol Table: This table contains symbols that are used at runtime and are resolved by the dynamic linker.

What you need to learn:

    Dynamic linking and the dynamic symbol table in ELF.
    How nm distinguishes between static and dynamic symbols.

Resources:

    Read more on dynamic linking.

7. How the nm Command Works

    What nm does: nm extracts and displays the symbol information from ELF object files. It typically outputs:
        The address of the symbol.
        The type (e.g., function, variable).
        The name of the symbol.
    Options: nm has several options, like sorting symbols, filtering, or displaying only certain types of symbols.

What you need to learn:

    Understand the typical output of nm.
    How nm handles different types of symbols (e.g., global, static, undefined).

Resources:

    NM Command.

8. Data Structures for Symbol Tables

    Arrays and Structures: The symbol table is often stored as an array of structures, with each structure representing a symbol and its associated data.
    String Tables: The names of the symbols are typically stored in a separate string table. Each entry in the symbol table has an index that corresponds to a string in the string table.

What you need to learn:

    How to parse an array of structures (for symbol tables).
    Accessing and parsing string tables.

Resources:

    Symbol Tables in ELF.

9. How to Use write() to Display Output

Since your environment restricts the use of functions like printf(), you’ll need to use write() to print output to the terminal:

    write() is the low-level system call that writes data to a file descriptor (e.g., stdout).
    You'll need to format your output yourself, such as printing symbols in a human-readable format.

What you need to learn:

    Basics of write() for printing strings and integers (in hex).
    How to manually handle formatting (like printing hex values for addresses).

Resources:

    Write System Call.

Suggested Learning Path:

    ELF File Structure: Learn how ELF files are structured and how to read them.
    System Calls: Understand file I/O, memory mapping, and working with system calls like open(), mmap(), and write().
    Symbol Tables: Focus on the concept of symbol tables, symbol types, and how they relate to linking and loading.
    Hexadecimal: Get comfortable with hexadecimal and binary representation for parsing data.
    Write a Simple Version of nm: Start small by reading an ELF file, printing some header information, and then slowly working up to parsing and displaying the symbols.